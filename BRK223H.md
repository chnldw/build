Microsoft Build
Secure and observe your APIs no matter where they run
Fernando Mejia
May 2023


FERNANDO MEJIA: Hello everyone. Welcome to one of the first sessions, breakout rooms in Build. How is everything going? How's the session going? Enjoying so far? Well, this is going to be a really interesting session. We're going to talk about APIs. A very interesting topic, of course, for the ones in the room, probably for other people they just care about their mobile applications, their web applications. 
But if their APIs work correctly, no one should know about this layer. But this is a very important layer that connects all of our digital experiences. Before getting started, could you please do a raise of hands? Who is here developing some REST APIs, for example? Okay, nice REST. Anyone doing some SOAP APIs, some Legacy APIs there? Great. Anyone doing gRPC? Not yet. What sockets? Oh, we have Wonder? Anyone doing GraphQL APIs? Interesting. We have some very exciting news for you today. So let's get started. My name is Fernando Mejia. I'm a Senior Program Manager for one of our services called Azure API Management. This is the agenda that we have for today. First, we're going to talk about the importance of APIs. 
If you're here in this session, we will do this very shortly because we know that you understand this part. We will talk also about API first development. What does it mean to start any new application, or any new digital experience? Thinking about the API first. Then we're going to talk about the journey to becoming API first development to get to do that. Then how Azure API Management can help you leverage all the features and capabilities that we have for you. Our team has been hard at work, so we're going to announce multiple features today. Some of them are completely premiers, have not been announced before, and some of them are being announced at this moment. So let's get started. 
Getting started with the importance of APIs. As you know, APIs are the fabric that connect all of our digital experience. Mobile applications, web applications, or now chat applications. Everything is connected now through API. A lot of protocols and standards that go with APIs. This is the way that we exchange data across multiple levels. This is the fabric that connects our digital world now. This is also the way that we deliver innovation. For example, we can take the example of Open AI and ChatGPT. When they announced REST API, in March, everyone started creating all these mobile applications, they started creating these, for example, VS Code integrations, and all these possible experiences with that API. 
Even ChatGPT came with their own mobile application this week. APIs are the ones that can accelerate and can deliver this innovation to many people and many users around the globe. Even as you know, with Cloud, Azure, for example, everything is delivered through API. Again, APIs are very important, and this helps us also, we can create digital experiences, for example. In the case of OpenAI and ChatGPT, you can see now that they are extending into a Plugin model where everyone can develop a Plugin and can Plugin into ChatGPT, and they can deliver extra functionality, for example, for booking a flight, or booking a trip, things like that. So this can create this economy like a marketplace also. Power connected experiences, for example, everything in Azure is delivered through an API. No matter if you are using the Azure portal, you're using our SDKs, or you're using the Azure CLI, you're going to get the exact same data, the exact same states of your components. Everything is connected through these APIs. Finally, another very important thing, APIs help us to enable scalability. 
We have many usage of our services and we need to scale out and there are modern software architecture patterns that can help us do this, for example, with Microservices or even with PasS infrastructure that can help us along this way. What is API-first development? Basically it means when we are going to develop a new experience either a web application or a mobile application, the first thing that we think about is basically the API contract. This contract between the clients and the servers. We try to adhere to that contract. We iterated over time. It will evolve over time, but that is the first thing that we think about. 
The APIs become the foundational block of every digital experience. This means things like API contract first. Normally also before we started developing the data model, when we're going to do an application we thought about the tables or, for example, the collections. In this world, we're going to think about this API contract first. This API contract would look like a GraphQL schema or OpenAPI Specification. It could take many, many ways, many formats. That's not okay. It's important to create a clear and consistent interface between clients and servers. This is what the API contracts can do for us. Basically the work will be to evolve this over time, create new versions and do validations. We can do some tooling. We can use some tooling to keep this API contract in place for our clients and also for our servers. 
The journey to API-first, development organization is going to be different for every company. There are some companies, probably some of you that are very way advanced in this journey and some others that we're just starting. Normally we see in our customers that, API's explode within their organization and they start to struggle to govern them and secure them. But others, they're a little bit ahead over this and they have already an API platform. This is going to be a little bit different for everyone. But here we're going to recommend some of the capabilities that you need to build to be ready for this API-first development. 
The first thing is that if you have APIs, you should be able to do API Discovery and you should be able to share your APIs with others and across multiple roles. You have developers. If you have operators, or if you have data scientists, you should be able to share these APIs with the other users within your company. This is one of the first things. 
Another very important thing is testing your APIs. This is functional testing, but also a very important one that sometimes we don't do a lot, which is load testing. Load tester APIs under different conditions, under different parameters, under different infrastructure and APIs, we need to scale them correctly. Load testing is also very important. Observability, being able to know what's happening at every layer of your API as you know an API, for example, you can have your code running. We could have some load balancers, Application Gateways. 
If there is an error in API requests, we need to be able to tell where exactly that error is happening. Of course, the other thing is performance. If the latency is not good enough, we should be able to tell how much latency is each layer adding to my service. This is very important observability. Another important aspect, and of course this is one of the best, most important probably, which is Security and Compliance at runtime. 
This is more we can talk about authorization and authentication. APIs in the end are exposing some data. We need to know who is accessing this data. To what scope of this data do they have access, and what applications are trying to call our data? Authorization and Authentication is also very important in the world of APIs. In here there are many standards, certificates, or two OpenID Connect, and we can help you in this process. The other one, and this comes to the first question, multiple protocols for APIs. As you've been aware, there are new protocols for APIs coming along. Some of them are becoming more mature and mature over time. 
But this doesn't mean that all the older protocols will go away. When REST became so popular, SOAP APIs are still there. We have many customers still using SOAP APIs. When GraphQL becomes more popular doesn't mean that REST will go away. But we need to be able to handle all these different protocols. Hopefully we can use the best API protocol for, or use-case. For example, if we want to do communication between server and client bidirectionally, we could use GraphQL, or we could use web sockets, for example. If not, we can also use REST and other gRPC, for example, if it's service to service communication. So we should be able to leverage the advantages of all the standards and protocols. 
Finally, again, Security. But this is more and more focus on the Governance part, being able, for example, at an organization level. The first one is more like at runtime, the API Gateway being able to know who's calling you and block that call if some conditions are not met. But this last one means at an organization level, for example, being able to see all the API inventory that is running in your organization. 
Being able to see which endpoints are secured and which endpoints are unsecured, or for example, which endpoints are not being used in the whole organization. Here is when we have more like an API platform within our company. These are some of the capabilities that we recommend for you to build into this journey. Now we're going to show you how, with Azure API Management we can help you accelerate this journey. Please raise your hand if anyone is familiar with the Azure API Management Service? Okay, cool. 
We have some new ways, new features that we're going to show today. Also probably if you're not familiar, things always change with our service. We're going to change, chose some new integrations, and also some changes within the service with a demo that we have. We're going to cover most of this functionality in our demo, so we're not going to spend too much time here. Let's move on. We're going to start with a demo. 
We're going to show a Microservices API called Service Tracker. This is going to basically be a, I'm sorry. Just let's go back to the presentation. Yeah, I'm just going to show the architecture. Thank you. This is going to be a Microservices API. This is nowadays a standard application. We're going to have to the right, a web application based on React. To the left we're going to have four microservices, basically, we're going to have a microservice that brings data from flights, brings data from earthquakes, brings data from the weather, and all this data will be stored in a MongoDB Database. As you can see, this is standard web application, but what we're going to do is that we're going to take the standard application and we're going to evolve it into an API-first application. More like creating an API platform on top of what we have here. So that way we can empower more experiences, other applications, third-party users, internal users, or many other experiences that can do APIs. 
Now, we're going to go to the demo, please. Okay. This is our Service Tracker UI. This is our application. Here you can see that this application is running in a Kubernetes cluster. For example, I'm going to clear this, do a little bit zoom. I'm going to create my Kubernetes cluster. You can see here that I'm running five microservices. For example, each microservice has a second replica. We have flights API, data API, Mongo database, quakes API, the UI itself, and we have a weather API. In this case, those are being exposed as services within Kubernetes. 
This is the infrastructure we're running and this will be the application. You can come here, for example. You can query the data. For example, I can query this quakes microservices and say go to the original data source. That's also an API. Bring the data and store even the MongoDB database and store even a cache. The same we can do for flights and the same we can do for the weather API. Once we have that data in the MongoDB database, we can go and do some visualizations here. For example, we can see that we have a lot of airplanes coming to Seattle. 
Anyone just traveled by plane here for this event? Nice. Probably we have your flight here. Let's see better. It's going to be hard to be important, but we have multiple airplanes here. For example, earthquakes. A place that I come from, Chile, it's also a lot of movement there. We have some weather here also information. This is our basic application. Now we're going to start moving into, again, a more API platform or API-first focus. 
The first thing that we need to do is, and this is very important. Right now, this code only I know how it works. I have access to the code here and I can see flight API. It supports this operation. It has a GetEndpoint. It has the status endpoint, but only I know how this code works or the developers that worked with me. I want to share this information with more people. That's the idea to empower others to use these APIs. 
The first thing we have to do is we have to have an OpenAPI Specification or this API contract. Everything runs around this. If it's a GraphQL schema, we need to define it. If it's an OpenAPI or a gRPC Protobuf, that's the important thing. Everything will evolve around this. For example, you can see here the weather API. These are the operations that I support. 
This is my OpenAPI Specification in YAML. I can export it to JSON and OpenAPI 2.0, 3.0 and we can try from here. We can try the API and we get this basic information. This is the most important part, the contract. We need to either build this or there's some tooling also to generate this contract completely, automatically. Once we have that, we basically can come to our Azure API Management Service and we can start importing these APIs very quickly with this contract. For example, we're going to start onboarding these APIs, flights API. I'm going to leave this here, flights. Here I'm going to start using this concept called Products. 
This is a concept from API Management where with Products I can group or bundle multiple APIs together and start giving access away to the first type of user, which is developers. I want other developers to consume these APIs. Through these products, I can control the access. I can say, if developers have access to the starter product, they can use this API. There's a role-based access control here that we can do. We're going to create this one. We're going to add the weather API also. I'm going to go here, weather API. I'm also going to start adding it to some products. 
Another details. For example, these APIs are not running with HTTPS. They are just running with HTTP. But since API Management is doing like a proxy, I can expose HTTPS to the front, but underneath I'm having HTTP. But of course, this is not ideal. But we're going to do it like this. Forwarding here. The same HTTPS on the front, but HTTP on the back. Now let's see how we can reuse this. Now I have this API onboarded to API management. 
Now I can go to this other component of API Management that is called a Developer Portal. Since most of you are familiar with API Management Service, you know that, for example, now that I have onboarded those APIs, I can sign in here. Refresh a little bit. Open it again. I can copy here the URL of the Developer Portal. This is part of the service. We can paste it here. I'm going to log in as a Developer. Now, I can see what APIs have been exposed to me. This is the first way to reuse and expose my APIs in this case to Developers. Here I can do self-service. I can try and get access to a starter product that is going to allow me to do five calls per minute. 
Very basic stuff. If you're familiar with Azure API Management, you already know this service probably very well. But there's another way today that were announcing of sharing your APIs with others. In the case of the Developer Portal, this is a one-to-one relationship. For every API Management you create, you will have one Developer Portal. But now we have a completely new service that we are just announcing today. That is called Microsoft API Center. API Center is going to be another service. It's not going to be part of Azure API Management. You will need to provision this in the Azure portal. This is being released as private preview today. We're going to share a link and you can test it. The idea with API Center is to share your APIs with another type of users. For example, data scientists or API platform operators or business stakeholders. 
The main difference is that API Center has a relationship of one-to-many API Management gateways. With API Center, you can bring your APIs from Apigee, for example, from AWS API Gateway, from MuleSoft API Management. The idea is to have a single inventory for all of your APIs. Here, right now, it's a private preview, so it's going to be with very limited functionality. But basically you can also register your APIs here. I can register the flights API. I can say this is going to be a REST API. Yeah. This is going to be an initial version. 
Again, we're focusing again in the contract. This contract is going to evolve over time. What stage are we in this API design, We can add the specification also. In here, the interesting part is that I can add more APIs. For example, I can add a GraphQL implementation. I can say this is a GraphQL. Flights API, initial version also. This is in preview. I can upload here a GraphQL specification. This is a completely new service. Again, here we're also going to separate the actual API contract from the underlying implementation and from where it is running. There will be this concept of the API. There will also be this concept of versionings and also implementations. Where is this API being deployed? Here we can add a deployment and say this is a Microservices running a Kubernetes cluster in Azure, for example. There will also be this concept of Environments. These environments could represent multiple types of API gateways. For example, you could have here an environment where my APIs are running within my organization in Azure API Management, but you can have another API gateway like Apigee or MuleSoft API Management. This API Center is a solution to have all those API centralized in a single place. Let's go back to the presentation. 
With those tools, the Developer Portal and the new API Center, we can start doing this capability, API discovery and reusability for multiple types of roles within our organization. Another important part that we mentioned is API Testing and Design. Let's see. Who here uses Postman for testing your APIs? Perfect. Anyone uses the REST VS Code extension? Nice. Now, Postman just came up with extension for VS Code just this week. API testing is also very important. We need to see what information are we getting. This adheres to the API contract to start adding this to our applications. 
But also low testing is also very important. We have some functionalities here to share with you. Let's go back to the demo, please. Again, once we have our APIs onboarded to Azure API Management, we can start to do some very cool things. For example, this is something that we released some months ago. We can export. Now there's this option to export to Postman. We can click here export to Postman. We're going to select the workspace. Let's see. I've forgotten the name of my workspace. It's just my workspace. Let's try that again. Well, we're going to show one that I already exported a couple of minutes ago. 
For example, when you export an API, it will show up as a collection in your workspace in Postman. An interesting thing is that since we added these APIs to Products, we added a basic authentication. So now to call the APIs, we need to send a subscription key. This subscription key, for example, can be set at a higher level. For example, authorizations here. This is the subscription key, we just need to set this value, and I have it here. We're going to try and do a call. We're going to save this and let's do latest. The base URL, this will be the URL of the API manager and we're not going to call the API directly, and let's see if it works. 
Let me copy another subscription key, and this is the other. That should work. Going to do a call. Give me a second. I'm going to get a subscription key from here for the unlimited product that way we don't get any rate limiting, and I think I put a chat validation in that one. So we're going to try. Let's see current. Let's see latest. Well, basically, you can put a subscription key here and this will go into the API Management Gateway. Right now I cannot find the right one, so I'm a little bit mixed up. 
SPEAKER 1: API Management. 
FERNANDO MEJIA: Oh, yeah. It's just that I have two API managements, but no worry about that. But basically, you can export your API. Say, you onboarded to API Management into Postman collections, and you can start doing the calls from there and see how it works. The other thing that you can do now is that we have a service within Azure now called Azure Load Testing. Anyone's using Azure Load Testing for their APIs? Great. Azure Load Testing is based on JMeter, and basically this allows us to send. We can define a JMeter script, and this JMeter script can send multiple users to our APIs, into our applications, and we can see the behavior of our APIs under a lot of stress. We can send thousands of users. Like 5,000 of users to your APIs and see what breaks first. Is it API Management, is it your underlying backends? Is it your underlying databases? Here, for example, we have a JMeter script where we can try a specific in Azure API Management gateway. We can try multiple APIs and we can also try multiple subscription keys. We could try how the API behaves inside one product or inside another product, or how the API behaves in one API management or another one. 
It's really flexible, and we're going to start a run here. In this case, I will just run 10 users per minute, doing all these calls together, so I'm not going to break things because it's not prepared for that. But basically, it's going to provision all the infrastructure and it's going to start sending all this Lotus to your users. You can specify a get request, a post, and multiple operations. This is really, really useful. Let's wait to see if it runs. In the meantime, I can show you another one here that I just ran before. You can see here, during one minute, I send 10 users to call my specific API with my subscription key and with a payload, with a query parameters, and I can see, for example, the average response time, and the average request per second that I was able to handle. 
This is very important to know how much can your API handle because based on that, you either need to start auto-scaling or you need to start doing some optimizing within your applications. This is what we have here, so let's go back to the presentation. Now another very important aspect is Observability. In the case of Azure API Management, we have multiple ways for doing Observability. You can integrate API Management with Application Insights. 
You can integrate it with Log Analytics. You can also create your own events using Event Hubs, and we support other tools like Azure Managed Grafana also, and something that we call Request Tracing. This is very important and we're going to go back to the demo and see this at play. I'm going back to my Azure API Management instance here. For example, you can see here that I have integrated this with Application Insights. Application Insights has this very useful functionality that is called Live Metrics. 
With Live Metrics, you can see near real-time how much requests or failures are happening at the gateway level. The other important part of Application Insights is that you can plug your own applications. You can put the SDK into your own code and you can see all these layers together to see what's happening within your API and how it is going. We're going to test this. For example, we're going to start doing some requests here. 
For example, going here in the latest, we're going to try this with the product, and we're going to send multiple calls. You can see here that almost in near real time, we can see all these requests come into your service. For example, this goes also very good with Azure Load Testing. When you do your Azure Load Testing, this is a very good way to know, for example, how many requests is the API Management receiving and how many requests is your underlying backend receiving, your actual code, your API code. 
This should be the same, but here you have all this vision in near real-time. Of course, this also is persisted. If you want to do queries, eventually you want to get all the requests, you'd want to get the performance operation. This is persisted using Kusto Query. Here you can get all this information of all these requests coming to your gateway. Application Insights will be the recommendation. Of course, another important part, and this is more like a debugger to be able to see what's happening in all the layers of your API Management, is a feature that we call Tracing. In the case of Tracing, in order to see these traces, we need to add some headers here because this is very internal information. 
It will reveal everything that is happening within the service, and also what's the latency coming from your backend and what's the latency added by the API Management. Let me see here what's the subscription key. Going to get another one, see how limited. This one should be the correct one. We're going to do a trace. 
For example, here you can see everything that is happening within the API Management Gateway. You can see when the request is coming. There is a basic inspection here. There's a course policy also. Is this an allowed host name or domain and then how much is the backend taking? This tracing is really important for you to see what's happening at each layer. Within API Management, we can also add some policies to change their behavior. With this, you can see how much latency is each layer adding. Let's go back to the presentation. 
We have Observability out of the way. In the case of Authentication and authorization with API Management, we have many options. For example, we can do the most popular ones, it's validate a jwt. If you have an identity server and you want to do all two or OpenID Connect, we can connect to either Azure ID. We can validate the incoming token. If it's signed by the identity server, we can validate claims inside the token if the user has access to the scope, if the user has access to this audience, and we can do very complex scenario with that. 
Through this policy that we call validate-jwt, we can also integrate with other identity servers. For example if you have Okta or Bing, we can also integrate with those. Of course we can also do certificate validations. We can do the subscription key, or we can do a combination of all of them. Here it's up to you, how much do you want to do, also of course, private networking. We can put the Kubernetes cluster and the API Management within the same virtual network, allow traffic with network security groups and very complex networking. 
We have many options available for you here. Are you familiar with the jwt validate policy here? Does anyone do all two, OpenID Connect? Perfect. We're going to go to the demo and show this very basically. We're going to take an operation here, let's say the current one. As you can see right now, I only have to pass a subscription key and I will get the result. This brings me all the flights, so it will take a couple of seconds. 
Now what we can do is that we can add a policy to ask for a jwt token. One of the interesting things that we can do right now, if you have GitHub Copilot, basically GitHub Copilot can write these policies for you. If you're not familiar with this, within API Management, you can add some behavior to this. You can say, if the request, if the user is called Fernando, give him less properties in the response or if the user is called Fernando, create an event in Event Hub. 
We can do a lot of logic within the gateway itself. But you just have to be aware that this logic might have an impact on the performance of your gateway. But this logic is written in XML policies and also snippets of, we call it C#, C# snippets of code. If you're not familiar with this, basically now you know. You can just write a comment and say, for example, validate jwt. For example, you can see GitHub Copilot automatically will create this scaffolding of this policy for me. I just need to press a tab here. I messed it up. And I have this scaffolding for my policy. It's not exactly the policy that I want, but it's good enough to get started. If XML is not your thing, well, we now have GitHub Copilot to help you out. 
Also this will be available with GitHub Copilot X, which is going to be a chat inside your VS Code ID. You can just ask him, give me an API Management policy to validate a jwt token. That's completely possible. We have integration with that now. Basically we're going to do this. We're going to validate jwt. I'm going to go here to Design. I'm going to put this in the inbound. In this case, I'm going to ask for a jwt in the authorization header and this jwt needs to be signed with this signature. I'm going to save this. This is in all operations, so now I'm going to try it. I'm just going to try current. Now I will need to add this header, authorization bearer. 
In this case, I created this jwt manually, but ideally this should be created by an identity server. I also need to pass a subscription key, so I'm going to do a call here. You can see that I can access the information. If I add a run Jot, for example, if I add some values here, this will be rejected because it's not valid with the signature and this is how we can add basic protection. Of course, the idea would be to connect to an identity server, so that's also supported. 
Let's go back to the presentation. We have a couple of minutes more. The other important part, and this is another feature that we're just releasing today is something that we call Synthetic GraphQL. Just as before in the past we were able to modernize SOAP APIs into REST APIs, we now have the capability to modernize REST and SOAP APIs into GraphQL APIs. With API Management, if you have GraphQL APIs, you can bring them along or if you want to start trying this new protocol, you can just bring your REST APIs and we can expose a GraphQL endpoint. We're going to show this working, and this is Synthetic GraphQL. 
Let's go back to the demo. Here we can come here and we can say add APIs. We can say GraphQL and let's put this, flights and weather API. The main advantage of GraphQL, for example, is that with GraphQL, we'll just have one single endpoint for our API. It's not going to be with REST like we need a for example, get status, get latest, get current endpoints. We just need to have a single endpoint and we can send queries to this end point. We can get just the data that we need and we can combine multiple entities. 
That's the main advantage of GraphQL. But in this case, I don't have a GraphQL API, I just have REST. I can choose this option called Synthetic GraphQL, which is actually coming GA, during this week, during Build. So it's completely open for you to try it in production environments. In here, basically, the only thing that I need again, is a contract. I need to be able to define this contract between API clients and servers. I have this affine here and I'm going to do HTTPS, and I'm going to call it flights-weather API. I'm also going to add it to products and I'm going to create this. For example as you see, the only thing that it asks for me is what is your GraphQL schema. 
You can define a GraphQL schema, but I don't have any underlying GraphQL API for this. I'm going to say, I want to expose data from flights and I want to expose data from weather. This is how this data is structured, every weather item has a Geometry Properties feature and these are the queries that I will support. Someone can ask for the Flights and someone can ask for the Weather. Now the interesting thing is that we can come here to this feature called Resolvers. 
This is the one that is going to do the magic, it's going to connect a query, coming into my GraphQL endpoint to a REST endpoint. I can come here and say Flights. If someone is asking for Flights, let's go to this endpoint. I'm going to put here, the Flights. I'm going to put here, I think this is current. Let's take a look. Flights current the latest will work. We put here latest. This will give you information for Flights and then if someone is doing a query about Weather I will resolve this into my REST endpoint. Case of Weather, I'm having the underlying API here. 
Weather it's going to be latest also. We're going to put here latest. We're going to create, and this is something that we call Resolvers. If we go back to the schema, you can see here that we have this link here. It means that when someone does that GraphQL query, we will forward it to a REST endpoint. Now we can test this here. Sample and let's say bring me the Flights with country and bring me the Weather. Bring me these properties. This is my GraphQL query. 
Here you can see that we're just getting the exact data that we're asking from this REST endpoints. We're not getting these extra things. This is going to help you have more optimized applications just to get the data that you need. 
Let's go back to the presentation and we're going to finish up. Finally, Governance, Compliance and Security at an organizational level. Here, you know we have this set of features. This is also being released during Build. There's a specific session for this called Defender for APIs. As you probably are familiar with Defender for Cloud, now Defender for Cloud can tell you, hey, I see that you have API Management instances. 
These API Management instances have these endpoints, I see that some of these endpoints don't have any security or some of these endpoints are not being called. The only thing that we need to do is to onboard the services to Defender for Cloud and we're going to start getting all this information. 
We will also have some Machine Learning process, looking at some knowledge-based the OWASP top 10 vulnerabilities and checking if any of your endpoints fits with those vulnerabilities. The API Center, this is a completely new product for you also, ready for you to try it in private preview right now. Again, this is going to be also a place to reuse, ensure your APIs, but across your organization, across API Gateway solution, it doesn't have to be running on API Management. Again, you know it's again those contracts of your APIs. 
We can put them here and share them across your whole organization. Finally, for the end, APIs are the foundational blocks for all of our digital experiences today. API-first development can accelerate this innovation and can accelerate this delivery of your APIs inside your organization or outside. Basically with Azure API Management, we can help you streamline this journey for you. We're just in time. 
If you have any questions, you can scan the QR code. We have some SMEs, some specialists within the chat that can help you out. But also, I will be in the expert meetup if you want, we can chat, we can discuss how you can use some of this technology available. 
During Build also, we have other sessions about API Management that can help you out. We have one specifically for GraphQL. How you can also, you know your databases can now become GraphQL endpoints out of the box. This is very interesting. Defender for APIs has a session just dedicated to that and also Power Platform, how you can show your APIs for local and no code citizen developers. 
That's everything we have and thank you very much for your time. 
[MUSIC] 
END
